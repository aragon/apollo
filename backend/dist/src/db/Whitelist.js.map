{"version":3,"file":"Whitelist.js","sourceRoot":"","sources":["../../../src/db/Whitelist.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;IAMI,mBAAoB,EAAY;QAAZ,OAAE,GAAF,EAAE,CAAU;IAAG,CAAC;IAS7B,2BAAO,GAAd;QACI,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK,CAAa,yBAAyB,CAAC,CAAA;IAC/D,CAAC;IAeY,6BAAS,GAAtB,UAAuB,SAAiB;;;;4BACrB,WAAM,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,EAAA;4BAAjD,WAAO,OAAO,CAAC,SAAkC,CAAC,KAAK,WAAW,EAAA;;;;KACrE;IAaY,gCAAY,GAAzB,UAA0B,SAAiB;;;;4BAC/B,WAAM,IAAI,CAAC,EAAE,CAAC,KAAK,CAAa,8CAA4C,SAAS,MAAG,CAAC,EAAA;4BAAjG,WAAO,CAAC,SAAyF,CAAC,CAAC,CAAC,CAAC,EAAA;;;;KACxG;IAcM,2BAAO,GAAd,UAAe,SAAiB,EAAE,SAAiB;QAC/C,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK,CAAW,yDAAuD,SAAS,YAAO,SAAS,OAAI,CAAC,CAAA;IACxH,CAAC;IAaY,8BAAU,GAAvB,UAAwB,SAAiB;;;;4BAC7B,WAAM,IAAI,CAAC,EAAE,CAAC,KAAK,CAAa,4CAA0C,SAAS,MAAG,CAAC,EAAA;4BAA/F,WAAO,CAAC,SAAuF,CAAC,CAAC,MAAM,GAAG,CAAC,EAAA;;;;KAC9G;IAaY,4CAAwB,GAArC,UAAsC,SAAiB;;;gBACnD,WAAO,IAAI,CAAC,EAAE,CAAC,KAAK,CAAS,mEAAiE,SAAS,MAAG,CAAC,EAAA;;;KAC9G;IAaY,gCAAY,GAAzB,UAA0B,SAAiB;;;;;4BAChB,WAAM,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,EAAA;;wBAAnD,IAAI,GAAa,SAAkC;wBAEzD,WAAO,CAAC,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,EAAA;;;;KAC3C;IACL,gBAAC;AAAD,CAAC,AAjHD,IAiHC","sourcesContent":["import Database from './Database'\n\nexport interface ListItem {\n    PublicKey: string,\n    Limit: number,\n    Executed: number\n}\n\nexport default class Whitelist {\n    /**\n     * @param {Database} db - The Database adapter\n     * \n     * @constructor \n     */\n    constructor(private db: Database) {}\n\n    /**\n     * Returns the whitelist\n     * \n     * @method getList\n     * \n     * @returns {Promise<ListItem[]>}\n     */\n    public getList(): Promise<ListItem[]> {\n        return this.db.query<ListItem[]>('SELECT * FROM whitelist')\n    }\n\n    /**\n     * TODO: Check return values of postgres package\n     * \n     * Checks if a key is existing\n     * \n     * @method keyExists\n     * \n     * @param {string} publicKey - The public key to look for\n     * \n     * @returns {Promise<boolean}\n     * \n     * @public\n     */\n    public async keyExists(publicKey: string): Promise<boolean> {\n        return typeof (await this.getItemByKey(publicKey)) !== 'undefined'\n    }\n\n    /**\n     * Returns a item from the whitelist by his public key\n     * \n     * @method getItemByKey\n     * \n     * @param {string} publicKey - The public key to look for\n     * \n     * @returns {Promise<ListItem>} \n     * \n     * @public \n     */\n    public async getItemByKey(publicKey: string): Promise<ListItem> {\n        return (await this.db.query<ListItem[]>(`SELECT * FROM whitelist WHERE PublicKey='${publicKey}'`))[0]\n    }\n\n    /**\n     * Adds a new item to the whitelist\n     * \n     * @method addItem\n     * \n     * @param {string} publicKey - The public key we would like to add\n     * @param {number} rateLimit - The amount of allowed transactions for this user\n     * \n     * @returns {Promise<ListItem>}\n     *  \n     * @public\n     */\n    public addItem(publicKey: string, rateLimit: number): Promise<ListItem> {\n        return this.db.query<ListItem>(`INSERT INTO whitelist (PublicKey, TxLimit) VALUES ('${publicKey}', '${rateLimit}')`)\n    }\n\n    /**\n     * Removes a item from the whitelist\n     *  \n     * @method deleteItem \n     * \n     * @param publicKey - The public key to delete\n     * \n     * @returns {Promise<boolean>}\n     * \n     * @public\n     */\n    public async deleteItem(publicKey: string): Promise<boolean> {\n        return (await this.db.query<ListItem[]>(`DELETE FROM whitelist WHERE PublicKey='${publicKey}'`)).length > 0\n    }\n\n    /**\n     * Increases the execution counter\n     * \n     * @method increaseExecutionCounter\n     * \n     * @param {string} publicKey \n     * \n     * @returns {Promise<number>}\n     * \n     * @public\n     */\n    public async increaseExecutionCounter(publicKey: string): Promise<number> {\n        return this.db.query<number>(`UPDATE whitelist SET Executed = Executed + 1 WHERE PublicKey='${publicKey}'`)\n    }\n\n    /**\n     * Returns true if the limit isn't reached otherwise false\n     * \n     * @method increaseExecutionCounter\n     * \n     * @param {string} publicKey \n     * \n     * @returns {Promise<boolean>}\n     * \n     * @public\n     */\n    public async limitReached(publicKey: string): Promise<boolean> {\n        const item: ListItem = await this.getItemByKey(publicKey)\n\n        return (item.Executed + 1) >= item.Limit\n    }\n}\n"]}