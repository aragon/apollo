{"version":3,"file":"Authenticator.js","sourceRoot":"","sources":["../../../src/auth/Authenticator.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,gDAAsD;AACtD,8CAAgD;AAChD,kDAAqD;AAUrD;IAcI,uBAAoB,SAAoB,EAAU,KAAY;QAA1C,cAAS,GAAT,SAAS,CAAW;QAAU,UAAK,GAAL,KAAK,CAAO;QARtD,gBAAW,GAAU,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAA;IAQK,CAAC;IActD,oCAAY,GAAzB,UAA0B,OAAuB;;;;;;;6BACzC,CAAA,OAAO,CAAC,MAAM,IAAI,KAAK,CAAA,EAAvB,eAAuB;wBACvB,OAAO,CAAC,IAAI,GAAG,EAAE,CAAA;;;;wBAEQ,KAAA,cAAA,OAAO,CAAC,GAAG,CAAA;;;;;wBAAnB,IAAI,WAAA,CAAA;wBACjB,OAAO,CAAC,IAAI,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAA;;;;;;;;;;;;;;;;;;;;;wBAGnC,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAc,CAAC,CAAC;wBACjD,OAAO,CAAC,IAAe,CAAC,OAAO,GAAG,qBAAW,CAAE,OAAO,CAAC,IAAe,CAAC,OAAO,CAAC,CAAA;;;wBAG9E,SAAS,GAAG,sBAAa,CAC3B,gBAAQ,CAAE,OAAO,CAAC,IAAe,CAAC,OAAO,CAAC,EACzC,OAAO,CAAC,IAAe,CAAC,SAAS,CACrC,CAAA;wBAGG,WAAM,IAAI,CAAC,aAAa,CACpB,OAAO,EACP,SAAS,CACZ,EAAA;;wBAJL,IACI,SAGC,EACH;4BACG,OAAgC,CAAC,SAAS,GAAG,SAAS,CAAA;4BAEvD,WAAM;yBACT;wBAED,MAAM,IAAI,CAAC,WAAW,CAAA;;;;KACzB;IAca,qCAAa,GAA3B,UAA4B,OAAuB,EAAE,SAAiB;;;;;;wBAC9D,KAAA,OAAO,CAAC,UAAU,KAAK,YAAY,CAAA;iCAAnC,cAAmC;wBAAI,WAAM,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,EAAA;;8BAAnC,SAAmC;;;wBAA9E,QAAgF;4BAC3E,OAAgC,CAAC,KAAK,GAAG,IAAI,CAAA;4BAE9C,WAAO,IAAI,EAAA;yBACd;wBAIG,KAAA,OAAO,CAAC,UAAU,KAAK,YAAY,CAAA;iCAAnC,cAAmC;wBAE9B,WAAM,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,SAAS,CAAC,EAAA;;8BAAzC,SAAyC;;wBAAM,WAAM,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,SAAS,CAAC,EAAA;;wBAA9C,KAAA,CAAC,CAAC,SAA4C,CAAC,CAAA;;;wBAA7F,KAAA,IAA8F,CAAA;gCAA9F,cAA8F;wBAC9F,WAAM,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,EAAA;;8BAAnC,SAAmC;;;wBAFvC,KAAA,IAGC,CAAA;;;wBALL,QAME;4BACG,OAAgC,CAAC,KAAK,GAAG,KAAK,CAAA;4BAE/C,WAAO,IAAI,EAAA;yBACd;wBAED,WAAO,KAAK,EAAA;;;;KACf;IACL,oBAAC;AAAD,CAAC,AA7FD,IA6FC","sourcesContent":["import { FastifyRequest } from 'fastify';\nimport { verifyMessage } from '@ethersproject/wallet';\nimport { arrayify } from '@ethersproject/bytes';\nimport { toUtf8Bytes } from '@ethersproject/strings';\nimport Whitelist from '../db/Whitelist';\nimport Admin from '../db/Admin';\nimport { Params } from '../../lib/AbstractAction';\n\nexport interface AuthenticatedRequest extends FastifyRequest {\n    publicKey: string\n    admin: boolean\n}\n\nexport default class Authenticator {\n    /**\n     * @property {HttpError} NOT_ALLOWED\n     * \n     * @private\n     */\n    private NOT_ALLOWED: Error = new Error('Not allowed action!')\n\n    /**\n     * @param {Whitelist} whitelist \n     * @param {Admin} admin\n     *  \n     * @constructor\n     */\n    constructor(private whitelist: Whitelist, private admin: Admin) { }\n\n    /**\n     * Checks if the given public key is existing and if this account is allowed to execute the requested action\n     * \n     * @method authenticate\n     * \n     * @param {FastifyRequest} request - The fastify request object\n     * @param {FastifyReply} reply - The fastify response object\n     * \n     * @returns Promise<undefined>\n     * \n     * @public\n     */\n    public async authenticate(request: FastifyRequest): Promise<undefined> {\n        if (request.method == 'GET') {\n            request.body = ''\n\n            for await (const data of request.raw) {\n                request.body += data.toString()\n            }\n\n            request.body = JSON.parse(request.body as string);\n            (request.body as Params).message = toUtf8Bytes((request.body as Params).message)\n        }\n\n        const publicKey = verifyMessage(\n            arrayify((request.body as Params).message),\n            (request.body as Params).signature\n        )\n\n        if (\n            await this.hasPermission(\n                request,\n                publicKey\n            )\n        ) {\n            (request as AuthenticatedRequest).publicKey = publicKey\n\n            return\n        } \n\n        throw this.NOT_ALLOWED\n    }\n\n    /**\n     * Checks if the current requesting user has permissions\n     * \n     * @method hasPermission\n     * \n     * @param {FastifyRequest} request \n     * @param {string} publicKey\n     * \n     * @returns {Promise<boolean>}\n     * \n     * @private \n     */\n    private async hasPermission(request: FastifyRequest, publicKey: string): Promise<boolean> {\n        if (request.routerPath === '/whitelist' && await this.admin.isAdmin(publicKey)) {\n            (request as AuthenticatedRequest).admin = true\n\n            return true\n        }\n\n        // TODO: Fire only one SQL statement to check if the key exists and if the limit is reached\n        if (\n            request.routerPath !== '/whitelist' && \n            (\n                (await this.whitelist.keyExists(publicKey) && !(await this.whitelist.limitReached(publicKey))) ||\n                await this.admin.isAdmin(publicKey)\n            )\n        ) {\n            (request as AuthenticatedRequest).admin = false\n\n            return true\n        }\n\n        return false\n    }\n}\n"]}